//#################################################
//# ###                                       ### #
//# ### Epics SNL Routines for		      ### #
//# ### Scan System	                      ### #
//# ###                                       ### #
//# ### author: D. Hampai - M. Montis         ### #
//# ###                                       ### #
//# ### Ref 1.0; 2025-12-04                   ### #
//#################################################
//#
//
program vitruvio_sncscan

%{
#include <math.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <errno.h>

#define MAX_MOTORS 20
#define MAX_DETECTORS 20

static FILE *detector_files[MAX_DETECTORS];
static char detector_paths[MAX_DETECTORS][512];

}%


/*=================== Declarations =========================*/

option +r;       /* Make the generated code reentrant, thus allowing more than one instance of the program to run on an IOC */
//
string name_server;
assign name_server to "{user}:server:name";
monitor name_server;
//
string name_exp_pv;
assign name_exp_pv to "{user}:experiment";
monitor name_exp_pv;
//
string name_exp[40];
//
// General Scan Configuration
//
int status_mode;
assign status_mode to "{user}:status";
monitor status_mode;
string actual_status[80];
//char actual_status[100];
assign actual_status to "{user}:state";
monitor actual_status;
char local_actual_status[80];

int scan_busy;
assign scan_busy to "{user}:scan_busy";
monitor scan_busy;
int scan_pause;
assign scan_pause to "{user}:scan_pause";
monitor scan_pause;
int scan_restart;
assign scan_restart to "{user}:scan_restart";
monitor scan_restart;
int scan_abort;
assign scan_abort to "{user}:scan_abort";
monitor scan_abort;

int end_scan;

//
//	Output Configuration Files
//
string output_path;
assign output_path to "{user}:scan:filepath";
monitor output_path;
int num_files_open;

//
//	Definition Scan Parameters
//
int num_mot;
assign num_mot to "{user}:num_motor";
monitor num_mot;
int num_det;
assign num_det to "{user}:num_detector";
monitor num_det;

double start[20];
assign start to "{user}:start";
monitor start;
double end[20];
assign end to "{user}:end";
monitor end;
double step[20];
assign step to "{user}:step";
monitor step;
//
double posit[20];
int index[20];
int npoints[20];
//
int total_points;
assign total_points to "{user}:total_points";
monitor total_points;
int current_point;
assign current_point to "{user}:current_point";
monitor current_point;
double scan_progress;
assign scan_progress to "{user}:scan_progress";
monitor scan_progress;
//
//	Definition Loop Parameters
//
int flags[20];
//
//	Definition Motors Variables
//
string motor[20];
assign motor to "{user}:motor";
monitor motor;

string mot_command[7];
assign mot_command to "{user}:motor_command";
monitor mot_command;
//
// Definition Detectors Variables
//
string detector[20];
assign detector to "{user}:detector";
monitor detector;

string det_command[7];
assign det_command to "{user}:detector_command";
monitor det_command;

// Local Strings
double motget;
assign motget to "";
monitor motget;
double motset;
assign motset to "";
monitor motset;

double detget;
assign detget to "";
monitor detget;
double detset;
assign detset to "";
monitor detset;

double pos;
double mov_wait;
double acq_wait;
//
//	Local Variables
//
double motor_mr[20];
assign motor_mr to {};
monitor motor_mr;
double motor_ma[20];
assign motor_ma to {};
monitor motor_ma;
int motor_reqmov[20];
assign motor_reqmov to {};
monitor motor_reqmov;
int motor_mov[20];
assign motor_mov to {};
monitor motor_mov;
int motor_reqpos[20];
assign motor_reqpos to {};
monitor motor_reqpos;
double motor_pos[20];
assign motor_pos to {};
monitor motor_pos;
int motor_status[20];
assign motor_status to {};
monitor motor_status;
//
int detector_reqstart[20];
assign detector_reqstart to {};
monitor detector_reqstart;
int detector_reqready[20];
assign detector_reqready to {};
monitor detector_reqready;
int detector_ready[20];
assign detector_ready to {};
monitor detector_ready;
int detector_reqdata[20];
assign detector_reqdata to {};
monitor detector_reqdata;
double detector_data[20];
assign detector_data to {};
monitor detector_data;
int detector_type[20];
assign detector_type to{};
monitor detector_type;
int detector_status[20];
assign detector_status to {};
monitor detector_status;

//

int i;
int j;
int k;
int d;
int command;
char temp_string[80];
char temp_status[80];
char temp_exp[40];
int all_connected;
int checkbusy;
int busyioc;
//
//
//
//
ss scan_status_mode {
/*=================== Start Program =========================*/
	state init {
		when (status_mode==0) {
			pvGet(name_exp_pv,SYNC);
			if (scan_busy==1) {
				printf("****************************\n");
				printf("********* ERROR!!! *********\n");
				printf("***    Exp %s is busy    ***\n", name_exp_pv);
				printf("****************************\n");
//				strcpy(local_actual_status, "Exp %s in use", name_exp_pv);
				strcpy(actual_status,local_actual_status);
				sprintf(actual_status, "Exp %s busy", name_exp_pv);
			} else {
				printf("**********************\n");
				printf("*** Ready for Scan ***\n");
				printf("***    Exp %s    ***\n", name_exp_pv);
				printf("**********************\n");
//				strcpy(actual_status, "Starting Scan Program");
				sprintf(local_actual_status, "Starting Scan %s", name_exp_pv);
				strcpy(actual_status,local_actual_status);
				printf("The Actual Status is = %s\n", actual_status);
				pvPut(actual_status,SYNC);
			}
		} state idle
	}
	state idle {
		when (status_mode==1) {
			printf("\n********************\n");
			printf("*** Assign Motor ***\n");
			printf("********************\n");
		} state assign_motor
		when (status_mode==2) {
			printf("\n***********************\n");
			printf("*** Assign Detector ***\n");
			printf("***********************\n");
		} state assign_detector
		when (status_mode==3) {
			printf("\n***************************\n");
			printf("*** Initialization Loop ***\n");
			printf("***************************\n");
		} state init_loop
		when (status_mode==4) {
			printf("\n*******************\n");
			printf("*** Connecting PV **\n");
			printf(" *******************\n");
		} state wait_connect
		when (status_mode==5) {
			printf("\n********************\n");
			printf("*** Prepare Loop ***\n");
			printf("********************\n");
		} state prepare_loop
			when (status_mode==6) {
			printf("\n******************\n");
			printf("*** Loop ***\n");
			printf("******************\n");
		} state loop
	}
/*=================== Assign Motor Varibles =========================*/
/*======================= status_mode = 1 ===========================*/
	state assign_motor {
		when () {
			printf("num_mot = %d\n", num_mot);
			for (i = 0; i < num_mot; i++) {
				printf("index = %d\n", i);
//
				command=0; 
				sprintf(temp_string, "%s:%s", motor[i], mot_command[command]); 
				printf("%s\n", temp_string);
				pvAssign(motor_mr[i],temp_string); 
//
				command=1;
				sprintf(temp_string, "%s:%s", motor[i], mot_command[command]);
				printf("%s\n", temp_string);
				pvAssign(motor_ma[i],temp_string);
//
				command=2;
				sprintf(temp_string, "%s:%s", motor[i], mot_command[command]);
				printf("%s\n", temp_string);
				pvAssign(motor_reqmov[i],temp_string);
//
				command=3;
				sprintf(temp_string, "%s:%s", motor[i], mot_command[command]);
				printf("%s\n", temp_string);
				pvAssign(motor_mov[i],temp_string);
//
				command=4;
				sprintf(temp_string, "%s:%s", motor[i], mot_command[command]);
				printf("%s\n", temp_string);
				pvAssign(motor_reqpos[i],temp_string);
//
				command=5;
				sprintf(temp_string, "%s:%s", motor[i], mot_command[command]);
				printf("%s\n", temp_string);
				pvAssign(motor_pos[i],temp_string);
//
				command=6;
				sprintf(temp_string, "%s:%s", motor[i], mot_command[command]);
				printf("%s\n", temp_string);
				pvAssign(motor_status[i],temp_string);
			}
			strcpy(local_actual_status, "Motors Parameters Assigned - Status 1");
			strcpy(actual_status,local_actual_status);
			pvPut(actual_status,SYNC);
			status_mode=0;
			pvPut(status_mode);
		} state idle
	}
/*=================== Assign Detector Varibles =========================*/
/*======================== status_mode = 2 =============================*/
	state assign_detector {
		when () {
			printf("num_det = %d\n", num_det);
			for (i = 0; i < num_det; i++) {
				printf("index = %d\n", i);
//
				command=0;
				sprintf(temp_string, "%s:%s", detector[i], det_command[command]);
				printf("%s\n", temp_string);
				pvAssign(detector_reqstart[i],temp_string);
//
				command=1;
				sprintf(temp_string, "%s:%s", detector[i], det_command[command]);
				printf("%s\n", temp_string);
				pvAssign(detector_reqdata[i],temp_string);
//
				command=2;
				sprintf(temp_string, "%s:%s", detector[i], det_command[command]);
				printf("%s\n", temp_string);
				pvAssign(detector_data[i],temp_string);
//
				command=3;
				sprintf(temp_string, "%s:%s", detector[i], det_command[command]);
				printf("%s\n", temp_string);
				pvAssign(detector_reqready[i],temp_string);
//
				command=4;
				sprintf(temp_string, "%s:%s", detector[i], det_command[command]);
				printf("%s\n", temp_string);
				pvAssign(detector_ready[i],temp_string);
//
				command=5;
				sprintf(temp_string, "%s:%s", detector[i], det_command[command]);
				printf("%s\n", temp_string);
				pvAssign(detector_type[i],temp_string);
//
				command=6;
				sprintf(temp_string, "%s:%s", detector[i], det_command[command]);
				printf("%s\n", temp_string);
				pvAssign(detector_status[i],temp_string);
			}
			strcpy(local_actual_status, "Detect. Parameters Assigned - Status 2");
			strcpy(actual_status,local_actual_status);
			pvPut(actual_status,SYNC);
			status_mode=0;
			pvPut(status_mode);
		} state idle
	}
/*=================== Initialize Loop =========================*/
/*=================== status_mode = 3 =========================*/

	state init_loop {
		when() {
			end_scan=0; // initialize end scan
			total_points = 1;
			for (i = 0; i < num_mot; i++) {
				flags[i]=0;  // init flags
				posit[i]=start[i];
				index[i]=0;
				npoints[i] = ( (end[i]-start[i]) / step[i] ) + 1;
				printf("the number steps fo %d motor is %d\n", i, npoints[i]);
				total_points *= npoints[i];
				printf("the step number is %d\n", total_points);
			}
			pvPut(total_points,SYNC);
			current_point=0;
			pvPut(current_point,SYNC);
			scan_busy=0;
			pvPut(scan_busy,SYNC);
			scan_restart=0;
			pvPut(scan_restart,SYNC);
			scan_pause=0;
			pvPut(scan_pause,SYNC);
			scan_abort=0;
			pvPut(scan_abort,SYNC);
		} state check_init
	}
//
	state check_init {
		when() {
			checkbusy=0;
			for (i = 0; i < num_mot; i++) {
//				busyioc=pvGet(motor_status[i],SYNC);
//				printf("Status Busy Motor %d = %d\n", i, busyioc);
				printf("Status Busy Motor %d = %d\n", i, motor_status[i]);
//				if (busyioc==1) {
				if (motor_status[i]==1) {
					checkbusy=checkbusy;
				} else {
					checkbusy++;
				}
			}
			for (i = 0; i < num_det; i++) {
//				busyioc=pvGet(detector_status[i],SYNC);
//				printf("Status Busy Detector %d = %d\n", i, busyioc);
				printf("Status Busy Detector %d = %d\n", i, detector_status[i]);
				if (detector_status[i]==1) {
					checkbusy=checkbusy;
				} else {
					checkbusy++;
				}
			}
			printf("0 if all the IOCs are ready = %d\n", checkbusy);
		} state ifbusy
	}
//
	state ifbusy {
		when(checkbusy==0) {
			printf("All the IOCs are in idle state");
		} state end_init
//		
		when(checkbusy!=0) {
			printf("At least one IOC is busy");
		} state error_busy
	}
//
	state end_init{
		when() {
			pvPut(total_points,SYNC);
			current_point=0;
			pvPut(current_point,SYNC);
			scan_busy=0;
			pvPut(scan_busy,SYNC);
			scan_restart=0;
			pvPut(scan_restart,SYNC);
			scan_pause=0;
			pvPut(scan_pause,SYNC);
			scan_abort=0;
			pvPut(scan_abort,SYNC);
//
			strcpy(local_actual_status, "Scan Initialized - Status 3");
			strcpy(actual_status,local_actual_status);
			pvPut(actual_status,SYNC);
			status_mode=0;
			pvPut(status_mode);
		} state idle
	}

/*=================== Conneting PV ===========================*/
/*=================== status_mode = 4 ========================*/
	state wait_connect {
/*		when (pvConnectCount() == pvAssignCount()) {
			printf("All PVs connected!\n");
			strcpy(local_actual_status, "PV Conneted - Status 4");
			strcpy(actual_status,local_actual_status);
			pvPut(actual_status,SYNC);
			status_mode=0;
			pvPut(status_mode);
		} state idle
		when (delay(1.0)) {
			printf("rasterScan: Waiting for connections... (%d/%d connected)\n", pvConnectCount(), pvAssignCount());
		} state wait_connect
*/
		when () {
			all_connected = 1;
// PV Motors
			printf("PV for %d motors\n", num_mot);
			for (i = 0; i < num_mot; i++) {
				if (!pvConnected(motor_mr[i])) {
					all_connected = 0;
					printf("Motor %d motor_mr not connected\n", i);
				}
				if (!pvConnected(motor_ma[i])) {
					all_connected = 0;
					printf("Motor %d motor_ma not connected\n", i);
				}			
				if (!pvConnected(motor_reqmov[i])) {
					all_connected = 0;
					printf("Motor %d motor_reqmov not connected\n", i);
				}
				if (!pvConnected(motor_mov[i])) {
					all_connected = 0;
					printf("Motor %d motor_mov not connected\n", i);
				}
				if (!pvConnected(motor_reqpos[i])) {
					all_connected = 0;
					printf("Motor %d motor_reqpos not connected\n", i);
				}
				if (!pvConnected(motor_pos[i])) {
					all_connected = 0;
					printf("Motor %d motor_pos not connected\n", i);
				}
				if (!pvConnected(motor_status[i])) {
					all_connected = 0;
					printf("Motor %d motor_status not connected\n", i);
				}
			}
			printf("Status PV-Motors Connections = %d\n", all_connected);
// PV Detectors
			printf("PV for %d detetors\n", num_det);
			for (i = 0; i < num_det; i++) {
				if (!pvConnected(detector_reqstart[i])) {
					all_connected = 0;
					printf("Detector %d detector_reqstart not connected\n", i);
				}
				if (!pvConnected(detector_reqdata[i])) {
					all_connected = 0;
					printf("Detector %d detector_reqdata not connected\n", i);
				}			
				if (!pvConnected(detector_data[i])) {
					all_connected = 0;
					printf("Detector %d detector_data not connected\n", i);
				}
				if (!pvConnected(detector_reqready[i])) {
					all_connected = 0;
					printf("Detector %d detector_reqready not connected\n", i);
				}
				if (!pvConnected(detector_ready[i])) {
					all_connected = 0;
					printf("Detector %d detector_ready not connected\n", i);
				}
				if (!pvConnected(detector_type[i])) {
					all_connected = 0;
					printf("Detector %d detector_type not connected\n", i);
				}
				if (!pvConnected(detector_status[i])) {
					all_connected = 0;
					printf("Detector %d detector_status not connected\n", i);
				}
			}
			printf("Status PV-Detectors Connections = %d\n", all_connected);
			if (all_connected==1) {
				printf("All PVs are connected!\n");
				strcpy(local_actual_status, "Detect. Parameters Assigned - Status 4");
				strcpy(actual_status,local_actual_status);
				pvPut(actual_status,SYNC);
				status_mode=0;
				pvPut(status_mode);
			} else {
				printf("All PVs are NOT connected!\n");
				strcpy(local_actual_status, "Error in PV Connection - Status 4");
				strcpy(actual_status,local_actual_status);
				pvPut(actual_status,SYNC);
				status_mode=0;
				pvPut(status_mode);
			}
		} state idle
//
//		when (delay(30.0)) {
//			printf("ERROR: Timeout waiting for PV connections\n");
//			printf("Connected: %d of %d\n", pvConnectCount(), pvAssignCount());
//		} state error_connect
	}


/*=================== Preparing Scan =========================*/
/*=================== status_mode = 5 ========================*/
	state prepare_loop {
		when () {
			strcpy(local_actual_status, "Preparing Loop - Status 5");
			strcpy(actual_status,local_actual_status);
			pvPut(actual_status,SYNC);
			scan_busy=1;
			pvPut(scan_busy,SYNC);
			for (i = 0; i < num_mot; i++) {
				motor_status[i]=0;
				pvPut(motor_status[i],SYNC);
			}
			for (i = 0; i < num_det; i++) {
				detector_status[i]=0;
				pvPut(detector_status[i],SYNC);
			}
			for (i = 0; i < num_mot; i++) {
				printf("motor to move = %d\n", i);
				printf("start[%d]= %f\n", i, start[i]);
				motor_ma[i]=start[i];
				pvPut(motor_ma[i],SYNC);
				motor_reqmov[i]=1;
				pvPut(motor_reqmov[i],SYNC);
				pvGet(motor_mov[i],SYNC);
				while(motor_mov[i]<1) {
					motor_reqmov[i]=1;
					pvPut(motor_reqmov[i],SYNC);
					pvGet(motor_mov[i],SYNC);
				}
				motor_reqpos[i]=1;
				pvPut(motor_reqpos[i],SYNC);
				pvGet(motor_pos[i], SYNC);
			}
			flags[0]=1; // Necessary to start the run
			strcpy(local_actual_status, "Ready to Start - status 5");
			strcpy(actual_status,local_actual_status);
			pvPut(actual_status,SYNC);
			status_mode=0;
			pvPut(status_mode);
		} state open_file
	}
//
//	Preparing Save Files
//
	state open_file {
		when() {
%{
			char timestamp[64];
			time_t now;
			struct tm *tm_info;
}%
			num_files_open = 0;
			for (i = 0; i < MAX_DETECTORS; i++) {
				detector_files[i] = NULL;
			}
			time(&now);
			tm_info = localtime(&now);
			strftime(timestamp, sizeof(timestamp), "%Y%m%d_%H%M%S", tm_info);
			for (i = 0; i < num_det; i++) {
/* Costruisci path completo per questo detector */
//				snprintf(detector_paths[i], sizeof(detector_paths[i]),"%s/scan_%s_%s.dat", output_path, detector[i], timestamp)
				snprintf(detector_paths[i], sizeof(detector_paths[i]),"/home/%s/%s/scan_%s_%s.dat", name_server, output_path, detector[i], timestamp);
				printf("Scan: Opening file for detector %i: %s\n", i+1, detector_paths[i]);
				
/* Apri file per questo detector */
				detector_files[i] = fopen(detector_paths[i], "w");
				if (detector_files[i] == NULL) {
					printf("Scan: ERROR - Cannot open file %s: %s\n", detector_paths[i], strerror(errno));
				} else {
					num_files_open++;
/* Scrivi header per questo detector */
					fprintf(detector_files[i], "# Raster Scan Data - Detector %d\n", i+1);
					fprintf(detector_files[i], "# Timestamp: %s\n", timestamp);
					fprintf(detector_files[i], "# Number of motors: %d\n", num_mot);
					fprintf(detector_files[i], "# Columns: ");
					for (j = 0; j < num_mot; j++) {
						fprintf(detector_files[i], "Motor%d\t", j+1);
					}
					fprintf(detector_files[i], "Detector%d\n", i+1);
					fflush(detector_files[i]);
				}
			}

			printf("Scan: Opened %d detector files successfully\n", num_files_open);
			if (num_files_open == 0) {
				printf("Scan: ERROR - No files opened! Check path and permissions\n");
			}
		} state loop
	}
/*====================== Loop ============================*/ 
/*================= status_mode = 6 ======================*/
	state loop {
		when(scan_abort==1) {
			printf("Scan Aborted by User\n");
		} state abort_scan
//
		when() {
			strcpy(local_actual_status, "Loop - Status 6");
			strcpy(actual_status,local_actual_status);
			strcpy(actual_status, temp_status);
			pvPut(actual_status,SYNC);
			status_mode=0;
			pvPut(status_mode);
		} state loops
	}


// LOOP Acquisizione
	state loops {
		when() {
		} state acquiring
	}


// LOOP NUOVE POSIZIONI
	state positions {
		when() {
			for (i=0; i<num_mot; i++) {
				if (flags[i] == 1) {
					if (index[i]==npoints[i]-1) {
						flags[i]=2;
						posit[i]=start[i];
						index[i]=0;
					} else {
						posit[i]=step[i]+posit[i];
						index[i]=index[i]+1;
					}
					printf("step=%d, i=%d, flag[%d]=%d, posit[%d]=%f, index[%d]=%d\n", current_point, i, i, flags[i], i, posit[i], i, index[i]);
					if (flags[i] == 2 && i == num_mot-1) {
						end_scan=1;
					} else if (flags[i] == 2) {
						flags[i+1]=1;
					} else {
//						printf
					}
				}
			}
		} state moving
	}

// LOOP MOVIMENTO MOTORI
	state moving {
		when(scan_abort==1) {
			printf("Scan Aborted by User\n");
		} state abort_scan
		when(scan_pause==1) {
			printf("Scan Aborted by User\n");
		} state pause_scan
		when() {
			for (i = 0; i < num_mot; i++) {
				motor_ma[i]=posit[i];
				pvPut(motor_ma[i],SYNC);
				motor_reqmov[i]=1;
				pvPut(motor_reqmov[i],SYNC);
				pvGet(motor_mov[i],SYNC);
				while(motor_mov[i]<1) {
					motor_reqmov[i]=1;
					pvPut(motor_reqmov[i],SYNC);
					pvGet(motor_mov[i],SYNC);
				}
				motor_reqpos[i]=1;
				pvPut(motor_reqpos[i],SYNC);
				pvGet(motor_pos[i], SYNC);
				printf("current_point = %d, posit[%d] = %f, motor_ma[%d] = %f, motor_pos[%d] = %f\n", current_point, i, posit[i], i, motor_ma[i],
					i, motor_pos[i]);	
			}
//
//			Reset Flags
//			
			for(i=0; i<num_mot; i++) {
				flags[i]=0;
			}
			flags[0]=1;
//
			status_mode=0;
			pvPut(status_mode);
		} state loops
	}

// LOOP ACQUISIZIONI
//	EXIT
	state acquiring {
		when (end_scan==1) {
		} state ending
//	Doing Acquisition
		when () {
			for (j=0; j < num_det; j++) {
				detector_reqstart[j]=1;
				pvPut(detector_reqstart[j],SYNC);
//				printf("Starting Acquisition");
				detector_reqready[j]=1;
				pvPut(detector_reqready[j],SYNC);
				pvGet(detector_ready[j],SYNC);
				while(detector_ready[j]<1) {
					detector_reqready[j]=1;
					pvPut(detector_reqready[j],SYNC);
					pvGet(detector_ready[j],SYNC);
				}
//				detector_reqdata[j]=1;
//				pvPut(detector_reqdata[j],SYNC);
				pvGet(detector_data[j],SYNC);
//
				if (detector_type[j] == 1) {
//					printf("The result for Detector %d = %f\n", j, detector_data[j]);
//					printf("%d, %f, %f, %.0f\n",current_point,posit[0],posit[1],detector_data[j]);
					printf("%d, %f, %f, %.0f\n",current_point,motor_pos[0],motor_pos[1],detector_data[j]);
					for (k=0; k<num_mot; k++) {
						fprintf(detector_files[j], "%.3f\t", motor_pos[k]);
					}
				fprintf(detector_files[j], "%.0f\n", detector_data[j]);
				fflush(detector_files[d]);
				} else if (detector_type[j] == 2) {
//					printf("The result for Detector %d = %f\n", j, detector_data[j]);
					printf("%d, %f, %f, %.0f\n",current_point,motor_pos[0],motor_pos[1],detector_data[j]);
				} else {
//					printf("The result for Detector %d = %f\n", j, detector_data[j]);
					printf("%d, %f, %f, %.0f\n",current_point,motor_pos[0],motor_pos[1],detector_data[j]);
				}
			}
//
//			printf("%d, %f, %f\n",current_point,posit[0],posit[1]);
//			printf("%d, %f, %f\n",current_point,motor_pos[0],motor_pos[1]);
			current_point++;
			pvPut(current_point,SYNC);
			scan_progress=100*current_point/total_points;
			pvPut(scan_progress);
		} state positions

	}


/*=================== End Scan =========================*/
	state ending {
		when() {
			for (i = 0; i < num_mot; i++) {
				motor_status[i]=1;
				pvPut(motor_status[i],SYNC);
			}
			for (i = 0; i < num_det; i++) {
				detector_status[i]=1;
				pvPut(detector_status[i],SYNC);
			}
			printf("\n****************\n");
			printf("*** End Scan ***\n");
			printf("****************\n");
			strcpy(local_actual_status, "Loop End - Status 6");
			strcpy(actual_status,local_actual_status);
			pvPut(actual_status,SYNC);
			scan_busy=0;
			pvPut(scan_busy,SYNC);
			status_mode=0;
			pvPut(status_mode,SYNC);
		} state close_file
	}

/*=================== Abort Scan =========================*/
	state abort_scan {
		when () {
			for (i = 0; i < num_mot; i++) {
				motor_status[i]=1;
				pvPut(motor_status[i],SYNC);
			}
			for (i = 0; i < num_det; i++) {
				detector_status[i]=1;
				pvPut(detector_status[i],SYNC);
			}
			printf("rasterScan: Cleaning up after abort\n");
//			scan_running = 0;
//			pvPut(scan_running);
			scan_progress = 0;
			pvPut(scan_progress,SYNC);
			scan_abort = 0;
			pvPut(scan_abort,SYNC);
			status_mode=0;
			pvPut(status_mode,SYNC);
		} state close_file
	}
/*=================== Close File =========================*/
	state close_file {
		when () {
			for (i = 0; i < num_det; i++) {
				if (detector_files[i] != NULL) {
					fclose(detector_files[i]);
					detector_files[i] = NULL;
					printf("Scan: Closed file: %s\n", detector_paths[i]);
				}
			}
			num_files_open = 0;
			printf("Scan: All files closed\n");
		} state idle

	}
/*=================== Pause =========================*/
	state pause_scan {
		when(scan_abort==1) {
			printf("Scan Aborted by User\n");
		} state abort_scan
//
		when (scan_restart==1) {
			scan_pause = 0;
			pvPut(scan_pause,SYNC);
		} state moving  
		when () {
			pvGet(scan_restart,SYNC);
			epicsThreadSleep(0.5);
		} state pause_scan
	}

/*=================== Error Connection =========================*/
	state error_connect {
		when () {
			printf("System in error state\n");
			printf("Check PV connections and IOC status\n");
			strcpy(local_actual_status, "Error PV Connection - Status 4");
			strcpy(actual_status,local_actual_status);
			pvPut(actual_status,SYNC);
			status_mode=0;
			pvPut(status_mode);
		} state idle
//		when (delay(5.0)) {
//			printf("rasterScan: Retrying connection...\n");
//		} state wait_connect
	}
//
	state error_busy {
		when () {
			printf("System in error state\n");
			printf("Busy IOCs\n");
			strcpy(local_actual_status, "IOCs busy - Status 3");
			strcpy(actual_status,local_actual_status);
			pvPut(actual_status,SYNC);
			status_mode=0;
			pvPut(status_mode);
		} state idle
	}

}
/*
SPDX-FileCopyrightText: 1998 Argonne National Laboratory

SPDX-License-Identifier: EPICS
*/
