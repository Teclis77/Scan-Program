program sncscan

/*=================== declarations =========================*/

option +r;	 /* Make the generated code reentrant, thus allowing more than one instance 
						of the program to run on an IOC */
double test;
assign test to "{user}:status";
monitor test;

double start;
assign start to "{user}:start";
monitor start;
double stop;
assign stop to "{user}:end";
monitor stop;
double step;
assign step to "{user}:step";
monitor step;

string motor;
assign motor to "{user}:motor";
monitor motor;

/* double motor_selected;
assign motor_selected to "";
monitor motor_selected; */

double command;
assign command to "{user}:create_command_label";
monitor command;

double command_selected;
assign command_selected to "";

string detector;
assign detector to "{user}:detector";
monitor detector;

string detector_selected;
assign detector_selected to "";

double command_detector;
assign command_detector to "{user}:create_command_detector_label";
monitor command_detector;

double command_detector_selected;
assign command_detector_selected to "";

string pvMotor;
string pvCommand;
string pvDetector;
string pvCommand_detector;

double pos_read;
assign pos_read to "";
monitor pos_read;
double pos_write;
assign pos_write to "";
monitor pos_write;

double pos;

double mov_wait;
double acq_wait;


ss scan_test {
	state init {
		when (test==0) {
			
			printf("Ready for Loop\n");
			} state idle
	}
	state idle {
		when (test==1) {
			printf("Start Loop\n");
			test=2;
			pvPut(test);
		} state loop
		when (test==3) {
                        command=6;
                        pvPut(command, SYNC);
			pvPut(motor, SYNC);
                        pvAssign(pos_read, motor);
			pos_read=1;
			pvPut(pos_read, SYNC);
			command=4;
                        pvPut(command, SYNC);
			pvAssign(pos_read, motor);
                        pvGet(pos_read, SYNC);
                        printf("Position = %f\n", pos_read);
			test=0;
			pvPut(test);
		} state idle
	}
	state loop {
		when (test==2) {
			pos=start;
			printf("Starting Scan...\n");
			while (pos <= stop) {
				printf("Position %f\n", pos);
	                        command=2;
	                        pvPut(command, SYNC);
				printf("Move %s\n", motor);
				mov_wait=0;
				while (mov_wait<3){
					printf("waiting for motion %f\n", mov_wait);
		                        command=3;
		                        pvPut(command, SYNC);
					printf("Waiting %s\n", motor);
					mov_wait++;
				}
                                command=4;
                                pvPut(command, SYNC);
                                printf("Position %s\n", motor);
				printf("Starting Acquiring\n");
				command_detector=1;
				pvPut(command_detector, SYNC);
				acq_wait=0;
                                while (acq_wait<3){
                                        printf("waiting for acquisition %f\n", acq_wait);
                                        command=2;
                                        pvPut(command_detector, SYNC);
                                        printf("Waiting %s\n", detector);
                                        acq_wait++;
                                }
				pos=pos+step;
			}
			test=0;
			pvPut(test);
		} state init
	}
}

/*
SPDX-FileCopyrightText: 1998 Argonne National Laboratory

SPDX-License-Identifier: EPICS
*/
